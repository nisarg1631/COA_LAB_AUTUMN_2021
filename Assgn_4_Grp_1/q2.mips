###############################################################################
    # Assignment Number: 4
    # Problem Number: 2
    # Semester Number: 5
    # Group Number: 1 
    # Group Members: Animesh Jha(19CS10070), Nisarg Upadhyaya (19CS30031)
###############################################################################

.globl  main
.data

# program output text constants
array: 
    .space 40    #10 element integer array
prompt_arr:
    .asciiz "Please enter an integer: "
sorting_sorted:
    .asciiz "Sorted array: "
newline:
    .asciiz "\n"

.text

# main program
#
# program variables
# array_length: $s0

main:
    jal     initStack
    li      $s0, 10 # initialise array length

    # read array from user
    li      $t0, 0  # i = 0

read_loop:
    li      $v0, 4  # print prompt_arr
    la      $a0, prompt_arr
    syscall                 
    
    li      $v0, 5   # read array element
    syscall   

    sw      $v0,array($t0)  # store array element in array[i]

    addi    $t0, $t0, 4         # i++
    bne     $t0, 40, read_loop  # loop termination condition

    lw      $fp, 0($sp) # restore frame pointer
    addi    $sp, $sp, 4 # restore stack pointer
    li      $v0, 10     # terminate program
    syscall

# recursive sort function


# swap function
#
# function variables
# n1: $a0
# n2: $a1
swap:
    move    $t0, $a0    # $t0 = n1
    move    $a0, $a1    # $a0 = n2
    move    $a1, $t0    # $a1 = n1
    jr		$ra			# return

# print array function
#
# function variables
#   $a0: array
#   $a1: N 
#   $t0: i
#   $t2: 4*i

print_array: 
    li      $t0, 0       # i = 0
    li      $t2, 0       # offset = 0

print_for_loop:
    bge     $t0, $a1, print_func_end  # if i>=n break

    lw      $t1, array($t2)   # load array[i] in $t1
    addi    $t2, $t2, 4       # offset = offset + 4
    
    li      $v0, 1      # print array[i]
    move    $a0, $t1    # load array[i] in $a0
    syscall             

    li      $v0, 11     # print space character
    li      $a0, 32     # load sapace character in $a0
    syscall

    addi    $t0, $t0, 1 # i++
    b       print_for_loop

print_func_end:
    li      $v0, 4      # print newline
    la      $a0, newline
    syscall

    jr      $ra         # return

# initStack function
#
# function variables
#
# -

initStack:
    addi    $sp, $sp, -4    # make space for storing frame pointer
    sw      $fp, 0($sp)     # store old frame pointer
    move    $fp, $sp        # update frame pointer to the new base of stack
    jr		$ra
    
# push function
#
# function variables
#
# n: $a0

pushToStack:
    addi    $sp, $sp, -4    # make space for storing the new element
    sw      $a0, 0($sp)     # save the new element to stack
    jr      $ra
